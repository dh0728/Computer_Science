# 🛎️ 질문: 데이터베이스가 Index 를 이용해 자료를 빠르게 검색하는 과정을, 우리 할머니도 알아들을 수 있도록 설명해 주시겠어요?

이질문에 대답을 하기 위해서는 Index 개념 부터 알아야 한다

## 🔖 Index
**추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조**

예를 들어 책에서 원하는 내용을 찾는다고 했을 때 책의 모든 내용을 확인하면서 찾는 것은 매우 비효율적이다.
그렇기 때문에 책의 맨 앞 또는 맨 뒤에 색인을 추가하여 빠르게 찾도록 하는 방법을 사용하는데 DB에서도 
데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 할 수 있다.

**그렇다면 인덱스를 무조건 사용하는게 좋을까??** <br>
인덱스의 장점과 단점에 대해 살펴보자

### 🚀 인덱스(index)의 장점과 단점 

#### 장점
1. 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
2. 전반적인 시스템의 부하를 줄일 수 있다.


#### 단점
1. 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
2. 인덱스를 관리하기 위해 추가 작업이 필요하고 그에 따른 오버헤드가 발생한.
    - INSERT: 새로운 데이터에 대한 인덱스를 추가
    - DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
    - UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가
3. 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

**🚨 오버헤드** : 프로그램의 실행흐름 도중에 동떨어진 위치의 코드를 실행시켜야 할 때 , **추가적으로 시간,메모리,자원이 사용되는 현상**입니다.
한마디로 정의하자면,  오버 헤드는 특정 기능을 수행하는데 드는 간접적인 시간, 메모리 등 자원을 말한다. 

**정답은 NO!!!** <br>
만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 **인덱스의 크기가 비대해지고 그로 인해 성능이 오히려 저하되는 역효과**가 발생할 수 있다. 
UPDATE와 DELETE가 빈번하게 발생되면 실제 사용하는 데이터보다 인덱스가 더 많이 존재하게 되고 SQL문 처리시에 비대해진 인덱스로 인해 성능이 떨어지게 된다.
인덱스(index)를 사용하면 좋은 경우는
1. 규모가 작지 않은 테이블
2. INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
3. JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
4. 데이터의 중복도가 낮은 컬럼
그와 기타 등등이 있다

다시 돌아와서 질문에 대한 자세한 답을 얻기 위해 **인덱스의 자료구조**에 대해 알아보자 

## 🔖 인덱스의 자료구조

### 1. 해시 테이블 (Hash Table)
해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 **빠른 데이터 검색이 필요할 때 유용**하다. 
해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조이다.

하지만 해시테이블은 실제로 잘 사용되지 않는다.
그 이유는 
해시 테이블은 등호(=) 연산에 최적화되어있기 때문이다. DB내에서는 부등호(<,>)연산이 자주 사용되는데, 
해시 테이블내의 **데이터들은 정렬되어있지 않으므로** "특정 값보다 큰 값들" 또는 "작은 값들"을 찾으려면, 모든 데이터를 일일이 뒤져야 한다


### 2. B+Tree

![image](https://github.com/user-attachments/assets/1c865b30-c567-40a5-8546-5ffafa06b790)


**자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조**이다. 
기존의 B-Tree는 어느 한 데이터의 검색은 효율적이나 모든 데이터를 한 번 순회하는데에는 트리의 모든 노드를 방문해야 하므로 비효율적인데 이것을 개선한것이 B+Tree이다.

B+Tree는 모든 노드에 데이터(Value)를 저장했던 BTree와 다른 특성을 가지고 있다.
- leaf 노드(데이터노드)에만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
- leaf node를 제외한 레벨의 노드들에는 더 이상 data pointer(실제 데이터가 저장된 주소 포인터)가 존재하지 않는다. 
- leaf 노드들은 LinkedList로 연결되어 있다.
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.

![image](https://github.com/user-attachments/assets/37d34e05-eb49-4a66-b29e-f34a9ae1c4fa)


**🚨 Linked List** 
- 데이터 목록을 다루는 가장 단순한 자료구조로, 데이터가 순차적으로 연결된 선형 구조로 되어있다.
- Linked List는 노드(Node)라는 요소로 구성되어 있는데, 노드는 데이터를 저장하는 부분과 다음 노드에 대한 포인터로 이루어져 있음.

#### 장점
1. leaf node에만 데이터 저장하므로 메모리 확보. -> 하나의 node에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색속도 높일 수 있음.
2. Full Scan의 경우 leaf node에만 데이터 저장되어있고, 이들이 Linked List로 연결되어있어 선형 시간이 소모됨.

### 단점
반드시 특정 key에 접근하기 위해서 leaf node까지 가야한다. (B-Tree는 최상의 경우 특정 key를 root node에서 찾을 수 있다)

#### 그럼 인덱스에서는 B+Tree를 주로 이용할까?
인덱스 컬럼은 부등호(< , >)를 이용한 순차 검색 연산이 자주 발생한다.
-> B+Tree의 Linked List를 이용하면 효율적인 순차 검색이 가능.

#### B+Tree의 SELECT, INSERT, DELETE
- B+Tree의 SELECT는 B-Tree와 동일.

## INSERT
key의 수가 최대보다 적은 leaf node에 삽입하는 경우
해당 node의 가장 앞이 아닌 곳에 삽입되는 경우는 단순히 삽입.
하지만, leaf node의 가장 앞에 삽입되는 경우는, 해당 node를 가리키는 부모 node의 포인터의 오른쪽에 위치한 key를 K로 바꿔준다. 그리고 leaf node끼리 Linked list로 이어줘야 하므로 삽입된 key에 Linked list로 연결한다. 

### 추가 참고사항
실제 InnoDB에서 쓰이는 B+Tree는 좀 더 복잡한 형상을 띄고 있. leaf node들뿐 아니라 그 상위 레벨의 노드들도 링크드 리스트로 연결되어 있으며, 싱글 링크드 리스트가 아닌 더블 링크드 리스트로 구현했다고 한다 
- 노드 간 이동 및 구조 변경이 더 빠름
- 양방향 탐색이 가능하면 더 빠르게 검색할 수 있다.

## 궁금했던 것
1. 그럼 한 노드에는 몇개의 키가 저장될 수 있냐??

DBMS(MySQL, PostgreSQL, Oracle, MongoDB 등)마다 B+Tree의 차수(Order, M)를 다르게 설정할 수 있다. DB마다 자동 조정인 것도 있고 수동 설정 가능한 것도 있다고 한다. 

디스크 I/O 성능을 최적화하기 위해 B+Tree 노드를 "페이지 단위(Page Size)"로 관리한다. 즉, 한 노드는 한 페이지(Page)로 저장되며, 페이지 크기에 따라 저장 가능한 Key 개수도 결정됨.

또한 Key의 타입에 따라서도 달라질수 있다.
Key값이 크면 한 노드에 저장할 수 있는 Key의 개수가 줄어든다. 




